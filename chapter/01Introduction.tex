
\chapter{引言}\label{chp:01Introduction}


本书讨论了可验证计算（VC）。可验证计算是指一种名为交互式证明（IPs）和论证的密码学协议，证明者能够向验证者提供证明者正确地执行了所请求的计算的保证。交互式证明和论证在20世纪80年代被提出，代表了一个陈述为真的“证明”包括什么概念上的重大扩展。传统上的证明是一个静态对象，可以很容易地通过逐步检查来检验正确性，因为证明的每个单独步骤都应该易于验证。相比之下，交互式证明允许证明者和验证者之间的进行交互，以及允许无效证明以微小但非零的概率通过验证。交互式证明和论证之间的区别在于，论证（而非交互式证明）允许存在对错误陈述的“证明”，只要找到这些“证明”需要巨大的计算能力就可以。\footnote{比如说，一个不是IP的论证系统，可能会使用密码系统，使得作弊的证明者有可能找到一个可通过验证的对假陈述的“证明”，当且仅当证明者可以攻破密码系统。}

20世纪80年代中期和90年代初的著名理论结果表明，至少原则上讲，可验证计算协议可以达到惊人的成就：包括让手机可以去监控强大但不受信任（甚至恶意）的超级计算机的执行，让计算能力较弱的外设（例如，安全卡读卡器）将安全核心工作外包给强大的远程服务器，以及让数学家仅通过查看所谓证明中的几个符号就能对定理的正确性具有很高的信心。\footnote{只要证明以一种特定的、略微有些冗余的形式书写。具体见第\ref{chp:09PCP}章中对概率可检验证明（PCPs)的讨论。}


当VC协议具有一种称为\dotemph{零知识} 的性质时，它会在密码学环境中非常有用。零知识的意思是证明或论证除了其本身的有效性之外，不会泄露任何信息。

为了具体说明为什么零知识协议有用，考虑以下来自身份认证的典型例子。假如Alice选择了一个随机口令$x$，公开了一个哈希值$z=h(x)$。其中$h$是一个单向函数，给定一个对随机选择$x$ 的 $z=h(x)$， 需要大量计算能力才能找到 $z$ 在 $h$ 下的原像， 即一个满足 $h\left(x^{\prime}\right)=z$ 的 $x^{\prime}$。 
假如Alice 在之后想要说服 Bob 她是发布 $z$ 的同一个人。她可以通过向 Bob 证明她知道一个满足 $h\left(x^{\prime}\right)=z$ 的 $x^{\prime}$ 来实现这一点。这将使 Bob 相信 Alice 是发布 $z$ 的同一个人, 因为这意味着 Alice 要么一开始就知道 $x$, 要么她反转了 $h$ （这被认为是超出了 Alice 的计算能力）。

Alice 如何让 Bob 相信她知道 $h$ 下 $z$ 的原像？ 一个简单的证明是 Alice 将 $x$ 发送给 Bob，Bob 可以轻松检验 $h(x)=z$。 但这样所揭示的信息比 Alice 知道 $z$ 的原像要多得多。 具体来说它揭示了原像本身。 Bob 可以使用该知识永远冒充 Alice，因为现在他也知道 $z$ 的原像了。

为了防止 Bob 获悉可能泄露口令 $x$ 的信息，给出不能揭示任何超出其自身有效性的内容的证明是很重要的。 这正是零知识性质所保证的。

本书的一个特定目标是描述构造所谓的零知识简洁非交互式知识论证（简称 zk-SNARKs）的各种方法。 “简洁”意味着证明很短。 “非交互”意味着证明是静态的，由来自证明者的单个消息组成。 （第二个）“知识”大致意味着协议不仅确定一个陈述为真，而且证明者\dotemph{知晓}一个“证据”来证明该陈述为真。 \footnote{例如，上述身份验证场景中确实需要对“存在一个口令 $x$ 使得 $h(x)=z$”这一陈述进行零知识\dotemph{知识}证明。 这是因为应用要求 Bob 不仅要确信在 $h$ 下\dotemph{存在} $z$ 的原像 $x$（如果 $h$ 是满射函数，这将始终为真），而且还要确信Alice 知道 $x$。}满足所有这些性质的论证系统在整个密码学中有无数应用。

对密码学相关的高度特定化的陈述（如证明离散对数的知识\cite{Sch89}）的实用零知识协议已经有了数十年了。然而，通用零知识协议直到最近才变得足够高效，可以用于密码部署中。通用的意思是，协议设计技术适用于任意计算。这一令人兴奋的进展包括了漂亮的新协议的提出，并引发了各界对零知识证明和论证的浓厚兴趣。本书旨在以统一的方式让人们能够轻松理解这些协议设计的主要思想和方法。

\subsubsection{背景和上下文} 在20世纪80年代中期和90年代，理论计算机科学家理论计算机科学家发现IP 和论证系统可以比传统的静态和信息论安全 \footnote{信息论安全}的 $\mathbf{NP}$ 证明（至少在渐近意义上）更高效 。
刻画这些协议能力的基础定理（例如 $\mathbf{IP=PSPACE}$ \cite{LFKN92,Sha92}、$\mathbf{MIP=NEXP}$ \cite{BFL91} 和 PCP 定理 \cite{ALM+98,AS98}）都是计算复杂性理论中最具影响力和最著名的定理。 \footnote{$\mathbf{IP=PSPACE}$和$\mathbf{MIP=NEXP}$的结果在本书中都有所涉及，分别参见第4.5.5节和第\ref{8.5}节。}

尽管其的渐近效率不错，但通用 VC 协议长期以来一直被认为是实际中完全不可用的，这有着充分的理由：该理论的朴素实现将具有高得可笑的具体开销（即使对非常短的计算，证明者也需要运行数万亿年）。 但在过去十年中，随着相应的从理论到实践的飞跃，VC 协议的开销方面有了重大改善。 尽管通用 VC 协议的实现仍然有些昂贵（尤其是对证明者而言），但如果 VC 协议是零知识的，那么付出这种开销通常是合理的，因为零知识协议支持的那些应用如果没有它们则可能是完全不可能的。 此外，公链的新兴应用提高了证明相对简单陈述的重要性，尽管成本高昂，但在这些陈述上运行现代 VC 协议是可行的。

\subsubsection{零知识协议设计方法及本书的理念}  
论证系统通常分两步开发。 
开发一个信息论安全协议（例如 IP、\dotemph{多证明者交互式证明} (MIP) 或\dotemph{概率可检查证明} (PCP)），以对单个或多个证明者假定以某种受限方式行事建模。（例如，在 MIP 中，会假定证明者不会相互发送有关他们从验证者那里收到的挑战的信息）。 
第二步，信息论安全的协议与密码学相结合，以“强制”（单个）证明者以受限方式行事，从而产生一个论证系统。 这第二步通常还会赋予所生成的论证系统重要的性质，例如零知识、简洁性和非交互性。 如果生成的论证系统满足所有这些性质，那么它实际上是一个 zk-SNARK。

目前为止，有多种可行的方法可以开发高效的 zk-SNARKs，这些方法可以根据它们所基于的信息论安全的协议类型进行分类。 这些包括 (1) IP、(2) MIP、(3) PCP，或更准确地说是称为\dotemph{交互式预言证明} (IOP) 的相关概念，它是 IP 和 PCP 的混合，以及 (4) \dotemph{线性}\emph{PCP}。 下文第 \ref{1.2.1}-\ref{1.2.3} 节更详细地概述了这些模型。 本书以一种统一的方式解释了如何在所有四种信息论安全的模型中设计高效的协议，并强调它们之间的共性。

IP、MIP 和 PCP/IOP 都可以通过将它们与称为\dotemph{多项式承诺方案}的密码学原语结合起来，而转化为简洁交互论证； 然后可以通过应用称为 \emph{Fiat-Shamir} \dotemph{转换}（第 \ref{5.2} 节）的密码学技术将交互式论证转换为非交互式和可公开验证的，从而产生一个SNARK。 从线性 PCP 到论证系统的转换有些不同，但也与某些多项式承诺方案密切相关。 与信息论安全的协议本身一样，本书以统一的方式涵盖了这些密码学转换。

由于 zk-SNARK 构造的两步本质，首先去理解证明和论证而\dotemph{不去}担心零知识，然后在最后理解如何作为“附加”性质实现零知识，通常是有帮助的 。
因此，我们直到本书的较后部分（第 \ref{chp:11ZKP} 章）才讨论了零知识。 
之前的章节致力于描述每个信息论安全模型中的高效协议，并解释如何将它们转化为简洁论证系统。

目前为止，zk-SNARKs 已经部署在许多现实世界的系统中，并且有一个由研究者、行业专家和开源软件开发人员组成的庞大而多样化的社区致力于改进和部署该技术。 本书假定很少的正规的数学背景，主要是要熟悉模运算、有限域和群论中的一些概念以及概率论基础。本书旨在作为对可验证计算和零知识感兴趣的任何人的资源。 但本书确实需要显著的数学成熟度以及对定理和证明的适应。 
了解标准复杂性类别（如 $\mathbf{P}$ 和 $\mathbf{NP}$）以及复杂性理论概念（如 $\mathbf{NP}$ 完备性）也很有帮助（但并非绝对必要）。


\subsubsection{本书中信息论安全模型的顺序} 
我们首先介绍 IP，然后是 MIP，然后是 PCP 和 IOP，再然后是线性 PCP。 该顺序大致遵循研究文献中模型出现的时间顺序。 有点讽刺的是，这些模型是以类似于\dotemph{倒}时间序的方式应用于实际的 SNARK 设计中的。 比如说第一个实用的 SNARK 就是基于线性 PCP 的。 事实上这并非巧合：引入线性 PCP 的主要动机就是为了得到更简单和更实用的简洁论证，特别是考虑到从 PCP 导出的论证的\dotemph{实际不可用性}。


\subsubsection{逐章大纲}
第 \ref{chp:02Randomness} 章通过两个简单但重要的案例研究，使读者熟悉随机性和概率证明系统的威力。 第 \ref{chp:03Definition} 章介绍了对整书有用的技术概念。 第 \ref{chp:04IP} 章描述了交互式证明的前沿。 第 \ref{chp:05FS} 章描述了 Fiat-Shamir 转换，一种用于从密码学协议中去除交互性的关键技术。 第\ref{chp:07argfromip} 章介绍了多项式承诺方案的概念，并将其与第 \ref{chp:04IP} 章的 IP 和第 \ref{chp:05FS} 章的 Fiat-Shamir 转换相结合，得到了本书中的第一个 SNARK。 第 \ref{chp:08MIP} 章描述了MIP的前沿及其派生的SNARK。 
\ref{chp:09PCP}-\ref{chp:10IOP}章 描述了 PCP 和 IOP，以及从中派生的 SNARK。

第 \ref{chp:06FrontEnds} 章是一个独立的章节，描述了以适用于比如说SNARK 的应用的格式来对计算机程序进行表示的技术。

第 \ref{chp:11ZKP} 章介绍了零知识的概念。 第 \ref{chp:12sigma} 章描述了一种特别简单的的零知识论证类型，称为$\Sigma$协议，并使用它们来导出承诺方案。 这些承诺方案是后续章节中介绍的更复杂协议的重要组成部分。 第 \ref{chp:13CP} 章描述了将非零知识协议转换为零知识协议的高效技术。 第 \ref{chp:14PCDL}-\ref{chp:16PC} 章介绍实用的多项式承诺方案，可用于将任何 IP、MIP 或 IOP 转换为简洁零知识知识论证 (zkSNARK)。 第 \ref{chp:17LPCP} 章介绍了设计 zkSNARK 的最后一种方法，即通过线性PCP。 第\ref{chp:18Recursion}章描述了如何递归组合 SNARK 以降低开销并实现重要的原语，例如所谓的\dotemph{增量可验证计算}。 最后，第 \ref{chp:19SNARK} 章详细介绍了实用 zkSNARKs 的设计范式的分类，并描述了每种方法的优缺点。


\subsubsection{阅读本书的建议} 本书当然可以愉快地从头读到尾，但非线性路径可能会是一个更快地提供全面了解 SNARK 设计技术的途径。 为此提出的建议如下。

第 \ref{chp:02Randomness} 章和第 \ref{chp:03Definition} 章介绍了贯穿所有后续章节的基础技术概念（有限域、IP、论证、低次扩展、Schwartz-Zippel 引理等），不熟悉这些概念的读者不应跳过。

读者接下来可能希望阅读\dotemph{最后}一章，第\ref{chp:19SNARK}章，这章提供了所有 SNARK 设计方法及其相互关系的鸟瞰图。 第\ref{chp:19SNARK}章使用了一些读者此时可能不熟悉的术语，但仍然应该是可以理解的，并且其所提供的上下文对阅读更多技术章节会有所帮助。

在那之后，本书有很多可能的阅读路径。 对最先部署在商业环境中的 SNARK 特别感兴趣的读者可参阅第 \ref{chp:17LPCP} 章关于线性 PCP 的内容。 除了使用了第 \ref{15.1} 节介绍的基于配对的密码学（以及最后对零知识的处理，这是第 \ref{chp:11ZKP} 章正式介绍的一个概念）之外，本章基本上是独立的，

或者，读者可以转向理解 SNARK 设计的另一种方法，即去结合\dotemph{多项式} \emph{IOP}（IP、MIP 和 PCP 是其特例）和\dotemph{多项式承诺方案}。

为了快速理解多项式 IOP，建议仔细阅读第 \ref{4.1} 节关于和校验协议的内容，然后是第 \ref{4.6} 节关于用于电路求值的 GKR 交互式证明协议，或第 \ref{8.2} 节给出的电路可满足性的 2-证明者 MIP。 
接下来，读者可以翻到第 \ref{chp:07argfromip} 章，其中解释了如何将此类协议与多项式承诺结合起来以获得简洁论证。

要理解多项式承诺方案，读者可以阅读第 \ref{10.4} 和 \ref{10.5} 节以了解基于 IOP 的多项式承诺，或者转向第 \ref{chp:12sigma} 章和第 \ref{chp:14PCDL}-\ref{chp:16PC} 章（按此顺序）以了解基于离散对数问题和配对的多项式承诺。

本书网页\footnote{\url{https://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.html}}上发布的一系列三个视频提供了关于多项式 IOP 和多项式承诺的概述。 读者可能会发现在详细阅读第 \ref{chp:04IP}-\ref{chp:10IOP} 章之前观看这些视频会很有用。


\subsubsection{首次阅读可跳过的材料} 
\ref{4.2}-\ref{4.5} 节专门介绍了和校验协议的详细示例应用，并解释了如何在其中高效实现证明者。 虽然这些部分包含有趣的结果并且有助于熟悉和检查协议，但后续章节并不依赖于此。 同样，关于 Fiat-Shamir 转换的第 \ref{chp:05FS} 章和关于前端的第 \ref{chp:06FrontEnds} 章在第一次阅读时是可选的。 \ref{9.3} 和 \ref{9.4} 节详细介绍了主要具有历史意义的 PCP，可以跳过。

第 \ref{chp:11ZKP} 章和第 \ref{chp:13CP} 章提供了零知识处理方法，大部分是独立的。 同样，第 \ref{chp:18Recursion} 章讨论了 SNARK 的组合，也是独立的。



\section{数学证明}
本书涵盖了\dotemph{数学证明}的不同概念及其在计算机科学和密码学中的应用。非正式地，我们所说的证明是指任何能使某人相信某项陈述为真的东西，而“证明系统”是指任何判定什么是令人信服的证明的程序。也就是说，证明系统由验证程序决定，该验证程序将任何陈述和声称该陈述为真的“证明”作为输入，判定该证明是否有效。

我们希望证明系统具有哪些性质呢？这有四个比较明显要有的。
\begin{itemize}
    \item 任何真陈述都应该有对其有效性的令人信服的证明。此性质通常称为\dotemph{完备性}。
    \item 任何假陈述都不应有令人信服的证明。此性质称为\dotemph{可靠性}。
    \item 理想情况下，验证程序将是“高效的”。 粗略地说，这意味着对简单的陈述应该有简短的（令人信服的）证明，且可以快速\dotemph{检验}。
    \item 理想情况下，证明生成也应该是高效的。 粗略地说，这意味着对简单的陈述应该有可以快速\dotemph{找到}的（令人信服的）短证明。
\end{itemize}


传统上，数学证明是可以逐行撰写并逐行检验其正确性的东西。 这种传统的证明概念正是复杂性类 $\mathbf{N P}$ \footnote{粗略地说，复杂性类 $\mathbf{N P}$ 包含所有这样的问题：任意输入上的正确答案为“是”或“否”，且对于所有“是”实例，存在一个有效可检验的（传统）证明，该证明的正确答案为“是”。 详细信息可参阅第 \ref{3.3} 节。} 所刻画的概念。但是在过去的30多年里，计算机科学家研究了更通用和更奇异的证明概念。这改变了计算机科学家对证明某事意味着什么的观念，并导致了复杂性理论和密码学的重大进步。


\section{我们将研究哪些非传统证明？}
本书中研究的所有证明概念本质上都是概率性的。
即验证程序将做出随机选择，且可靠性将以（非常）高的概率在这些随机选择上成立。 
也就是说，验证程序会以（非常）小的概率宣布假陈述为真。

\subsection{交互式证明 （IP）} \label{1.2.1}
要理解什么是交互式证明，考虑以下应用场景可能会有帮助。 想象一家企业（验证者）使用某云计算提供商来存储和处理其数据。 
企业将其所有数据发送并存储到云（证明者），企业仅存储非常小的数据的“秘密”摘要（云不知道用户的秘密摘要）。 
随后，企业向云询问有关其数据的问题，通常以计算机程序$f$的形式提出，即企业希望云使用庞大的计算基础设施在其数据上运行该程序。 
云这样做了之后向用户发送程序的输出 $f(\text{数据})$。 企业可以使用交互式证明系统 (IP) 来获得该输出正确性的一个正式\dotemph{保证}，而不是盲目地去相信云在数据上正确执行了该程序。

在 IP 中，企业询问云，发送一系列挑战并接收一系列响应。 在询问结束时，企业必须决定是接受有效答案还是拒绝无效答案。 有关此交互的图，请参见图 1.1。

IP 的完备性保证了如果云在数据上正确运行了程序并遵循所规定的协议，那么用户将被说服接受有效的回答。 IP 的可靠性保证了如果云返回错误的输出，那么\dotemph{无论云如何努力诱使用户}接受回答为有效，用户都将以很高概率拒绝回答为无效。 直观上，IP 的交互本质使得企业可以利用意外元素（即云无法预测企业的下一个挑战这一事实）来捕捉到云的谎言。

值得一提的是 IP 和传统静态证明之间的一个有趣区别。静态证明是\dotemph{可传递}的，如果 Peggy（证明者）向 Victor（验证者）提供一个陈述为真证明，Victor 可以继续去说服 Tammy（第三方）相同的陈述为真，只需复制证明即可。 反之，一个交互式证明是不可传递的。 Victor 可以通过向 Tammy 发送他与 Peggy 的交互脚本来尝试说服 Tammy 该陈述为真，但 Tammy 并不会被说服，除非 Tammy 相信 Victor 正确地代表了交互过程。 这是因为 IP 的可靠性仅在每次 Peggy 向 Victor 发送响应时，Peggy 不知道 Victor 接下来将响应什么挑战时才成立。 仅凭脚本并不能向Tammy保证这一点。

\subsection{论证系统} \label{1.2.2}
论证系统就是IP，只是其中的可靠性性要求只需要防止在多项式时间内运行的作弊证明者。\footnote{这大致意味着如果输入的大小为 $n$，那么证明者的运行时间（对于足够大的 $n$ 值）应该以 $n$ 的某个常数幂为界，例如 $n^{10} $。}
论证系统会使用密码学。 
粗略地说，在论证系统中，作弊证明者无法欺骗验证者接受假陈述，除非它攻破了某个密码系统，且破解该密码系统被认为需要超多项式时间。

\subsection{多证明者交互式证明（MIP）/概率可检验证明（PCP）等} \label{1.2.3}
MIP 类似于 IP，但有多个证明者，并且假设这些证明者不会相互共享他们从验证者那里收到的挑战的信息。 MIPs 的一个常见类比是在审讯之前将两名或更多犯罪嫌疑人放在不同的房间里，看他们是否能讲出一致的故事。 
执法人员可能不会对MIPs的研究为这种做法提供了理论依据感到太意外。
具体来说，MIPs的研究表明，将证明者锁在不同的房间里，然后分别审问他们，这可以说服审问者相信比在一起审问时更复杂的陈述。


在 PCP 中，证明与传统数学证明一样是静态的，但验证者只能从证明中读取少量（可能是随机选择的）字符。 
\footnote{更准确地说，PCP验证者去读证明中尽可能多的内容是可以的。 然而，仅在验证者只需要阅读证明的一小部分即可高置信度地确定证明是否有效的情况下，才认为PCP是高效的。} 
这类似于数学期刊的懒惰审稿人，他并不想费力地检查提交论文中的证明是否正确。 
PCP 定理 \cite{ALM+98,AS98}本质上指出，\dotemph{任何}传统的数学证明都可以写成特定格式，使这个懒惰的审阅者能够仅通过检查其中的几个词而对证明的有效性获得高度信心。

哲学上讲，MIP 和 PCP 都是非常有趣的研究对象，但它们并不能直接应用于大多数密码学场景中，因为它们对证明者（们）做出了不切实际或繁琐的假设。 
例如，任何 MIP 的可靠性仅在证明者不相互共享有关他们从验证者那里收到挑战的信息时才成立。 这在大多数密码学场景中并不直接有用，因为通常在这些场景中只有一个证明者，即使有多个证明者，也没有办法强制证明者不进行通信。 
类似地，虽然验证者只需读取 PCP 的几个字符，但一个PCP的直接实现却需要证明者将整个证明传输给验证者，这将是大多数现实场景中的主要开销所在（尽管例子中有一个懒惰的期刊审稿人）。 也就是说，一旦证明者将整个证明传输给验证者了，再让验证者避免阅读整个证明几乎没有什么现实世界的好处。

然而，通过将 MIP 和 PCP 与密码学相结合，我们将看到如何将它们变成论证系统，这些论证系统\dotemph{可以}直接应用于密码学场景。 例如，我们将在 \ref{9.2} 节中看到如何将 PCP 变成一个论证系统，在该系统中，证明者\dotemph{不必}将整个 PCP 发送给验证者。

本书的第 \ref{10.2} 节实际上提供了一个统一的抽象，称为\dotemph{多项式}\emph{IOP}，在其中所有 IP、MIP 和 PCP 都是一个特例。 实际上，通过称为多项式承诺方案的密码学原语，任何多项式 IOP 都可以转换为具有短证明的论证系统。