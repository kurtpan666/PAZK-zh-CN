
\chapter{引言}\label{chp:01Introduction}


本书讨论了可验证计算（VC）。可验证计算是指一种名为交互式证明（IPs）和论证的密码学协议，证明者能够向验证者提供证明者正确地执行了所请求的计算的保证。交互式证明和论证在20世纪80年代被提出，代表了一个陈述为真的“证明”包括什么概念上的重大扩展。传统上的证明是一个静态对象，可以很容易地通过逐步检查来检验正确性，因为证明的每个单独步骤都应该易于验证。相比之下，交互式证明允许证明者和验证者之间的进行交互，以及允许无效证明以微小但非零的概率通过验证。交互式证明和论证之间的区别在于，论证（而非交互式证明）允许存在对错误陈述的“证明”，只要找到这些“证明”需要巨大的计算能力就可以。\footnote{比如说，一个不是IP的论证系统，可能会使用密码系统，使得作弊的证明者有可能找到一个可通过验证的对假陈述的“证明”，当且仅当证明者可以攻破密码系统。}

20世纪80年代中期和90年代初的著名理论结果表明，至少原则上讲，可验证计算协议可以达到惊人的成就：包括让手机可以去监控强大但不受信任（甚至恶意）的超级计算机的执行，让计算能力较弱的外设（例如，安全卡读卡器）将安全核心工作外包给强大的远程服务器，以及让数学家仅通过查看所谓证明中的几个符号就能对定理的正确性具有很高的信心。\footnote{只要证明以一种特定的、略微有些冗余的形式书写。具体见第\ref{chp:09PCP}章中对概率可检验证明（PCPs)的讨论。}


当VC协议具有一种称为\dotemph{零知识} 的性质时，它会在密码学环境中非常有用。零知识的意思是证明或论证除了其本身的有效性之外，不会泄露任何信息。

为了具体说明为什么零知识协议有用，考虑以下来自身份认证的典型例子。假如Alice选择了一个随机口令$x$，公开了一个哈希值$z=h(x)$。其中$h$是一个单向函数，给定一个对随机选择$x$ 的 $z=h(x)$， 需要大量计算能力才能找到 $z$ 在 $h$ 下的原像， 即一个满足 $h\left(x^{\prime}\right)=z$ 的 $x^{\prime}$。 
假如Alice 在之后想要说服 Bob 她是发布 $z$ 的同一个人。她可以通过向 Bob 证明她知道一个满足 $h\left(x^{\prime}\right)=z$ 的 $x^{\prime}$ 来实现这一点。这将使 Bob 相信 Alice 是发布 $z$ 的同一个人, 因为这意味着 Alice 要么一开始就知道 $x$, 要么她反转了 $h$ （这被认为是超出了 Alice 的计算能力）。

Alice 如何让 Bob 相信她知道 $h$ 下 $z$ 的原像？ 一个简单的证明是 Alice 将 $x$ 发送给 Bob，Bob 可以轻松检验 $h(x)=z$。 但这样所揭示的信息比 Alice 知道 $z$ 的原像要多得多。 具体来说它揭示了原像本身。 Bob 可以使用该知识永远冒充 Alice，因为现在他也知道 $z$ 的原像了。

为了防止 Bob 获悉可能泄露口令 $x$ 的信息，给出不能揭示任何超出其自身有效性的内容的证明是很重要的。 这正是零知识性质所保证的。

本书的一个特定目标是描述构造所谓的零知识简洁非交互式知识论证（简称 zk-SNARKs）的各种方法。 “简洁”意味着证明很短。 “非交互”意味着证明是静态的，由来自证明者的单个消息组成。 （第二个）“知识”大致意味着协议不仅确定一个陈述为真，而且证明者\dotemph{知晓}一个“证据”来证明该陈述为真。 \footnote{例如，上述身份验证场景中确实需要对“存在一个口令 $x$ 使得 $h(x)=z$”这一陈述进行零知识\dotemph{知识}证明。 这是因为应用要求 Bob 不仅要确信在 $h$ 下\dotemph{存在} $z$ 的原像 $x$（如果 $h$ 是满射函数，这将始终为真），而且还要确信Alice 知道 $x$。}满足所有这些性质的论证系统在整个密码学中有无数应用。

对密码学相关的高度特定化的陈述（如证明离散对数的知识\cite{Sch89}）的实用零知识协议已经有了数十年了。然而，通用零知识协议直到最近才变得足够高效，可以用于密码部署中。通用的意思是，协议设计技术适用于任意计算。这一令人兴奋的进展包括了漂亮的新协议的提出，并引发了各界对零知识证明和论证的浓厚兴趣。本书旨在以统一的方式让人们能够轻松理解这些协议设计的主要思想和方法。

\subsubsection{背景和上下文} 在20世纪80年代中期和90年代，理论计算机科学家理论计算机科学家发现IP 和论证系统可以比传统的静态和信息论安全 \footnote{信息论安全}的 $\mathbf{NP}$ 证明（至少在渐近意义上）更高效 。
刻画这些协议能力的基础定理（例如 $\mathbf{IP=PSPACE}$ \cite{LFKN92,Sha92}、$\mathbf{MIP=NEXP}$ \cite{BFL91} 和 PCP 定理 \cite{ALM+98,AS98}）都是计算复杂性理论中最具影响力和最著名的定理。 \footnote{The results IP=PSPACE and MIP=NEXP are both covered in this survey (see Sections 4.5.5 and 8.5 respectively).}




\subsubsection{零知识协议设计方法及本书的理念}  
论证系统通常分两步开发。 
开发一个信息论安全协议（例如 IP、\dotemph{多证明者交互式证明} (MIP) 或\dotemph{概率可检查证明} (PCP)），以对单个或多个证明者假定以某种受限方式行事建模。（例如，在 MIP 中，会假定证明者不会相互发送有关他们从验证者那里收到的挑战的信息）。 
第二步，信息论安全的协议与密码学相结合，以“强制”（单个）证明者以受限方式行事，从而产生一个论证系统。 这第二步通常还会赋予所生成的论证系统重要的性质，例如零知识、简洁性和非交互性。 如果生成的论证系统满足所有这些性质，那么它实际上是一个 zk-SNARK。

\subsubsection{本书中信息论安全模型的顺序} 
我们首先介绍 IP，然后是 MIP，然后是 PCP 和 IOP，再然后是线性 PCP。 该顺序大致遵循研究文献中模型出现的时间顺序。 有点讽刺的是，这些模型是以类似于\dotemph{倒}时间序的方式应用于实际的 SNARK 设计中的。 比如说第一个实用的 SNARK 就是基于线性 PCP 的。 事实上这并非巧合：引入线性 PCP 的主要动机就是为了得到更简单和更实用的简洁论证，特别是考虑到从 PCP 导出的论证的\dotemph{实际不可用性}。


\subsubsection{逐章大纲}
\subsubsection{阅读本书的建议}



\subsubsection{首次阅读可跳过的材料} Sections 4.2-4.5 are devoted to detailed example applications of the sum-check protocol and explaining how to efficiently implement the prover within it. While these sections contain interesting results and are useful for familiarizing oneself with the sum-check proto- col, subsequent chapters do not depend on them. Similarly, Chapter 5 on the Fiat-Shamir transformation and Chapter 6 on front-ends are optional on a first reading. Sections 9.3 and 9.4 provide PCPs that are mainly of historical interest and can be skipped.
Chapters 11 and 13 offer treatments of zero-knowledge that largely stand on their own. Similarly, Chapter 18 discusses SNARK composition and stands on its own.



\section{数学证明}
本书涵盖了\dotemph{数学证明}的不同概念及其在计算机科学和密码学中的应用。非正式地，我们所说的证明是指任何能使某人相信某项陈述为真的东西，而“证明系统”是指任何判定什么是令人信服的证明的程序。也就是说，证明系统由验证程序决定，该验证程序将任何陈述和声称该陈述为真的“证明”作为输入，判定该证明是否有效。

我们希望证明系统具有哪些性质呢？这有四个比较明显要有的。
\begin{itemize}
    \item 任何真陈述都应该有对其有效性的令人信服的证明。此性质通常称为\dotemph{完备性}。
    \item 任何假陈述都不应有令人信服的证明。此性质称为\dotemph{可靠性}。
    \item 理想情况下，验证程序将是“高效的”。 粗略地说，这意味着对简单的陈述应该有简短的（令人信服的）证明，且可以快速\dotemph{检验}。
    \item 理想情况下，证明生成也应该是高效的。 粗略地说，这意味着对简单的陈述应该有可以快速\dotemph{找到}的（令人信服的）短证明。
\end{itemize}


传统上，数学证明是可以逐行撰写并逐行检验其正确性的东西。 这种传统的证明概念正是复杂性类 $\mathbf{N P}$ \footnote{粗略地说，复杂性类 $\mathbf{N P}$ 包含所有这样的问题：任意输入上的正确答案为“是”或“否”，且对于所有“是”实例，存在一个有效可检验的（传统）证明，该证明的正确答案为“是”。 详细信息可参阅第 \ref{3.3} 节。} 所刻画的概念。但是在过去的30多年里，计算机科学家研究了更通用和更奇异的证明概念。这改变了计算机科学家对证明某事意味着什么的观念，并导致了复杂性理论和密码学的重大进步。


\section{我们将研究哪些非传统证明？}
本书中研究的所有证明概念本质上都是概率性的。
即验证程序将做出随机选择，且可靠性将以（非常）高的概率在这些随机选择上成立。 
也就是说，验证程序会以（非常）小的概率宣布假陈述为真。

\subsection{交互式证明 （IP）}
要理解什么是交互式证明，考虑以下应用场景可能会有帮助。 想象一家企业（验证者）使用某云计算提供商来存储和处理其数据。 
企业将其所有数据发送并存储到云（证明者），企业仅存储非常小的数据的“秘密”摘要（云不知道用户的秘密摘要）。 
随后，企业向云询问有关其数据的问题，通常以计算机程序$f$的形式提出，即企业希望云使用庞大的计算基础设施在其数据上运行该程序。 
云这样做了之后向用户发送程序的输出 $f(\text{数据})$。 企业可以使用交互式证明系统 (IP) 来获得该输出正确性的一个正式\dotemph{保证}，而不是盲目地去相信云在数据上正确执行了该程序。

在 IP 中，企业询问云，发送一系列挑战并接收一系列响应。 在询问结束时，企业必须决定是接受有效答案还是拒绝无效答案。 有关此交互的图，请参见图 1.1。

IP 的完备性保证了如果云在数据上正确运行了程序并遵循所规定的协议，那么用户将被说服接受有效的回答。 IP 的可靠性保证了如果云返回错误的输出，那么\dotemph{无论云如何努力诱使用户}接受回答为有效，用户都将以很高概率拒绝回答为无效。 直观上，IP 的交互本质使得企业可以利用意外元素（即云无法预测企业的下一个挑战这一事实）来捕捉到云的谎言。

值得一提的是 IP 和传统静态证明之间的一个有趣区别。静态证明是\dotemph{可传递}的，如果 Peggy（证明者）向 Victor（验证者）提供一个陈述为真证明，Victor 可以继续去说服 Tammy（第三方）相同的陈述为真，只需复制证明即可。 反之，一个交互式证明是不可传递的。 Victor 可以通过向 Tammy 发送他与 Peggy 的交互脚本来尝试说服 Tammy 该陈述为真，但 Tammy 并不会被说服，除非 Tammy 相信 Victor 正确地代表了交互过程。 这是因为 IP 的可靠性仅在每次 Peggy 向 Victor 发送响应时，Peggy 不知道 Victor 接下来将响应什么挑战时才成立。 仅凭脚本并不能向Tammy保证这一点。

\subsection{论证系统}
论证系统就是IP，只是其中的可靠性性要求只需要防止在多项式时间内运行的作弊证明者。\footnote{这大致意味着如果输入的大小为 $n$，那么证明者的运行时间（对于足够大的 $n$ 值）应该以 $n$ 的某个常数幂为界，例如 $n^{10} $。}
论证系统会使用密码学。 
粗略地说，在论证系统中，作弊证明者无法欺骗验证者接受假陈述，除非它攻破了某个密码系统，且破解该密码系统被认为需要超多项式时间。

\subsection{多证明者交互式证明（MIP）/概率可检验证明（PCP）等}
MIP 类似于 IP，但有多个证明者，并且假设这些证明者不会相互共享他们从验证者那里收到的挑战的信息。 MIPs 的一个常见类比是在审讯之前将两名或更多犯罪嫌疑人放在不同的房间里，看他们是否能讲出一致的故事。 
执法人员可能不会对MIPs研究为这种做法提供了理论依据感到意外。
具体来说，MIPs的研究表明，将证明者锁在不同的房间里，然后分别审问他们，这可以说服审问者相信比在一起审问时更复杂的陈述。

In a PCP, the proof is static as in a traditional mathematical proof, but the verifier is only allowed to read a small number of (possibly randomly chosen) characters from the proof. ${ }^{10}$ This is in analogy to a lazy referee for a mathematical journal, who does not feel like painstakingly checking the proofs in a submitted paper for correctness. The PCP theorem [ $\mathrm{ALM}^{+} 98$, AS98] essentially states that any traditional mathematical proof can be written in a format that enables this lazy reviewer to obtain a high degree of confidence in the validity of the proof by inspecting just a few words of it.

在 PCP 中，证明与传统数学证明一样是静态的，但验证者只能从证明中读取少量（可能是随机选择的）字符。 \footnote{More precisely, a PCP verifier is allowed to read as much of the proof as it wants. However, for the PCP to be considered efficient, it must be the case that the verifier only needs to read a tiny fraction of the proof to ascertain with high confidence whether or not the proof is valid.
} 这类似于数学期刊的懒惰审稿人，他不想煞费苦心地检查提交论文中的证明是否正确。 
PCP 定理 [ $\mathrm{ALM}^{+} 98$, AS98] 本质上指出，任何传统的数学证明都可以用一种格式编写，使这个懒惰的审阅者能够对证明的有效性获得高度的信心 通过检查它的几个词。

Philosophically, MIPs and PCPs are extremely interesting objects to study, but they are not directly applicable in most cryptographic settings, because they make unrealistic or onerous assumptions about the prover(s). For example, soundness of any MIP only holds if the provers do not share information with each other regarding what challenges they receive from the verifier. This is not directly useful in most cryptographic settings, because typically in these settings there is only a single prover, and even if there is more than one, there is no way to force the provers not to communicate. Similarly, although the verifier only reads a few characters of a PCP, a direct implementation of a PCP would require the prover to transmit the whole proof to the verifier, and this would be the dominant cost in most real-world scenarios (the example of a lazy journal referee notwithstanding). That is, once the prover transmits the whole proof to the verifier, there is little real-world benefit to having the verifier avoid reading the whole proof.

However, by combining MIPs and PCPs with cryptography, we will see how to turn them into argument systems, and these are directly applicable in cryptographic settings. For example, we will see in Section 9.2 how to turn a PCP into an argument system in which the prover does not have to send the whole PCP to the verifier.

Section 10.2 of this survey in fact provides a unifying abstraction, called polynomial IOPs, of which all of the IPs, MIPs, and PCPs that we cover are a special case. It turns out that any polynomial IOP can be transformed into an argument system with short proofs, via a cryptographic primitive called a polynomial commitment scheme.
